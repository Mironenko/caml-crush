/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include "pkcs11_rpc.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

rpc_ck_rv_t *
c_setuparch_3(arg1, clnt)
	pkcs11_int arg1;
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_SetupArch, xdr_pkcs11_int, &arg1, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_initialize_3(clnt)
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_Initialize, xdr_void, NULL, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetSlotList *
c_getslotlist_3(arg1, arg2, clnt)
	pkcs11_int arg1;
	pkcs11_int arg2;
	CLIENT *clnt;
{
	c_getslotlist_3_argument arg;
	static ck_rv_c_GetSlotList clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_GetSlotList, xdr_c_getslotlist_3_argument, &arg, xdr_ck_rv_c_GetSlotList, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetInfo *
c_getinfo_3(clnt)
	CLIENT *clnt;
{
	static ck_rv_c_GetInfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_GetInfo, xdr_void, NULL, xdr_ck_rv_c_GetInfo, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_WaitForSlotEvent *
c_waitforslotevent_3(arg1, clnt)
	rpc_ck_flags_t arg1;
	CLIENT *clnt;
{
	static ck_rv_c_WaitForSlotEvent clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_WaitForSlotEvent, xdr_rpc_ck_flags_t, &arg1, xdr_ck_rv_c_WaitForSlotEvent, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetSlotInfo *
c_getslotinfo_3(arg1, clnt)
	rpc_ck_slot_id_t arg1;
	CLIENT *clnt;
{
	static ck_rv_c_GetSlotInfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_GetSlotInfo, xdr_rpc_ck_slot_id_t, &arg1, xdr_ck_rv_c_GetSlotInfo, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetTokenInfo *
c_gettokeninfo_3(arg1, clnt)
	rpc_ck_slot_id_t arg1;
	CLIENT *clnt;
{
	static ck_rv_c_GetTokenInfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_GetTokenInfo, xdr_rpc_ck_slot_id_t, &arg1, xdr_ck_rv_c_GetTokenInfo, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_login_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_user_type_t arg2;
	opaque_data arg3;
	CLIENT *clnt;
{
	c_login_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_Login, xdr_c_login_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_logout_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_Logout, xdr_rpc_ck_session_handle_t, &arg1, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_OpenSession *
c_opensession_3(arg1, arg2, clnt)
	rpc_ck_slot_id_t arg1;
	rpc_ck_flags_t arg2;
	CLIENT *clnt;
{
	c_opensession_3_argument arg;
	static ck_rv_c_OpenSession clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_OpenSession, xdr_c_opensession_3_argument, &arg, xdr_ck_rv_c_OpenSession, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_closesession_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_CloseSession, xdr_rpc_ck_session_handle_t, &arg1, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_finalize_3(clnt)
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_Finalize, xdr_void, NULL, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetMechanismList *
c_getmechanismlist_3(arg1, arg2, clnt)
	rpc_ck_slot_id_t arg1;
	pkcs11_int arg2;
	CLIENT *clnt;
{
	c_getmechanismlist_3_argument arg;
	static ck_rv_c_GetMechanismList clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_GetMechanismList, xdr_c_getmechanismlist_3_argument, &arg, xdr_ck_rv_c_GetMechanismList, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_closeallsessions_3(arg1, clnt)
	rpc_ck_slot_id_t arg1;
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_CloseAllSessions, xdr_rpc_ck_slot_id_t, &arg1, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetSessionInfo *
c_getsessioninfo_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static ck_rv_c_GetSessionInfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_GetSessionInfo, xdr_rpc_ck_session_handle_t, &arg1, xdr_ck_rv_c_GetSessionInfo, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetMechanismInfo *
c_getmechanisminfo_3(arg1, arg2, clnt)
	rpc_ck_slot_id_t arg1;
	rpc_ck_mechanism_type_t arg2;
	CLIENT *clnt;
{
	c_getmechanisminfo_3_argument arg;
	static ck_rv_c_GetMechanismInfo clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_GetMechanismInfo, xdr_c_getmechanisminfo_3_argument, &arg, xdr_ck_rv_c_GetMechanismInfo, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_initpin_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_initpin_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_InitPIN, xdr_c_initpin_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_setpin_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	opaque_data arg3;
	CLIENT *clnt;
{
	c_setpin_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_SetPIN, xdr_c_setpin_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_seedrandom_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_seedrandom_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_SeedRandom, xdr_c_seedrandom_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_inittoken_3(arg1, arg2, arg3, clnt)
	rpc_ck_slot_id_t arg1;
	opaque_data arg2;
	opaque_data arg3;
	CLIENT *clnt;
{
	c_inittoken_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_InitToken, xdr_c_inittoken_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GenerateRandom *
c_generaterandom_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	pkcs11_int arg2;
	CLIENT *clnt;
{
	c_generaterandom_3_argument arg;
	static ck_rv_c_GenerateRandom clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_GenerateRandom, xdr_c_generaterandom_3_argument, &arg, xdr_ck_rv_c_GenerateRandom, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_findobjectsinit_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_attribute_array arg2;
	CLIENT *clnt;
{
	c_findobjectsinit_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_FindObjectsInit, xdr_c_findobjectsinit_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_FindObjects *
c_findobjects_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	pkcs11_int arg2;
	CLIENT *clnt;
{
	c_findobjects_3_argument arg;
	static ck_rv_c_FindObjects clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_FindObjects, xdr_c_findobjects_3_argument, &arg, xdr_ck_rv_c_FindObjects, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_findobjectsfinal_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_FindObjectsFinal, xdr_rpc_ck_session_handle_t, &arg1, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GenerateKey *
c_generatekey_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_attribute_array arg3;
	CLIENT *clnt;
{
	c_generatekey_3_argument arg;
	static ck_rv_c_GenerateKey clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_GenerateKey, xdr_c_generatekey_3_argument, &arg, xdr_ck_rv_c_GenerateKey, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GenerateKeyPair *
c_generatekeypair_3(arg1, arg2, arg3, arg4, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_attribute_array arg3;
	rpc_ck_attribute_array arg4;
	CLIENT *clnt;
{
	c_generatekeypair_3_argument arg;
	static ck_rv_c_GenerateKeyPair clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	arg.arg4 = arg4;
	if (clnt_call(clnt, c_GenerateKeyPair, xdr_c_generatekeypair_3_argument, &arg, xdr_ck_rv_c_GenerateKeyPair, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_CreateObject *
c_createobject_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_attribute_array arg2;
	CLIENT *clnt;
{
	c_createobject_3_argument arg;
	static ck_rv_c_CreateObject clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_CreateObject, xdr_c_createobject_3_argument, &arg, xdr_ck_rv_c_CreateObject, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_CopyObject *
c_copyobject_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_object_handle_t arg2;
	rpc_ck_attribute_array arg3;
	CLIENT *clnt;
{
	c_copyobject_3_argument arg;
	static ck_rv_c_CopyObject clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_CopyObject, xdr_c_copyobject_3_argument, &arg, xdr_ck_rv_c_CopyObject, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_destroyobject_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_object_handle_t arg2;
	CLIENT *clnt;
{
	c_destroyobject_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_DestroyObject, xdr_c_destroyobject_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetAttributeValue *
c_getattributevalue_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_object_handle_t arg2;
	rpc_ck_attribute_array arg3;
	CLIENT *clnt;
{
	c_getattributevalue_3_argument arg;
	static ck_rv_c_GetAttributeValue clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_GetAttributeValue, xdr_c_getattributevalue_3_argument, &arg, xdr_ck_rv_c_GetAttributeValue, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_setattributevalue_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_object_handle_t arg2;
	rpc_ck_attribute_array arg3;
	CLIENT *clnt;
{
	c_setattributevalue_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_SetAttributeValue, xdr_c_setattributevalue_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetObjectSize *
c_getobjectsize_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_object_handle_t arg2;
	CLIENT *clnt;
{
	c_getobjectsize_3_argument arg;
	static ck_rv_c_GetObjectSize clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_GetObjectSize, xdr_c_getobjectsize_3_argument, &arg, xdr_ck_rv_c_GetObjectSize, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_WrapKey *
c_wrapkey_3(arg1, arg2, arg3, arg4, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_object_handle_t arg3;
	rpc_ck_object_handle_t arg4;
	CLIENT *clnt;
{
	c_wrapkey_3_argument arg;
	static ck_rv_c_WrapKey clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	arg.arg4 = arg4;
	if (clnt_call(clnt, c_WrapKey, xdr_c_wrapkey_3_argument, &arg, xdr_ck_rv_c_WrapKey, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_UnwrapKey *
c_unwrapkey_3(arg1, arg2, arg3, arg4, arg5, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_object_handle_t arg3;
	opaque_data arg4;
	rpc_ck_attribute_array arg5;
	CLIENT *clnt;
{
	c_unwrapkey_3_argument arg;
	static ck_rv_c_UnwrapKey clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	arg.arg4 = arg4;
	arg.arg5 = arg5;
	if (clnt_call(clnt, c_UnwrapKey, xdr_c_unwrapkey_3_argument, &arg, xdr_ck_rv_c_UnwrapKey, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_DeriveKey *
c_derivekey_3(arg1, arg2, arg3, arg4, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_object_handle_t arg3;
	rpc_ck_attribute_array arg4;
	CLIENT *clnt;
{
	c_derivekey_3_argument arg;
	static ck_rv_c_DeriveKey clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	arg.arg4 = arg4;
	if (clnt_call(clnt, c_DeriveKey, xdr_c_derivekey_3_argument, &arg, xdr_ck_rv_c_DeriveKey, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_digestinit_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	CLIENT *clnt;
{
	c_digestinit_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_DigestInit, xdr_c_digestinit_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_Digest *
c_digest_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_digest_3_argument arg;
	static ck_rv_c_Digest clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_Digest, xdr_c_digest_3_argument, &arg, xdr_ck_rv_c_Digest, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_digestupdate_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_digestupdate_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_DigestUpdate, xdr_c_digestupdate_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_DigestFinal *
c_digestfinal_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static ck_rv_c_DigestFinal clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_DigestFinal, xdr_rpc_ck_session_handle_t, &arg1, xdr_ck_rv_c_DigestFinal, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_digestkey_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_object_handle_t arg2;
	CLIENT *clnt;
{
	c_digestkey_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_DigestKey, xdr_c_digestkey_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_signinit_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_object_handle_t arg3;
	CLIENT *clnt;
{
	c_signinit_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_SignInit, xdr_c_signinit_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_Sign *
c_sign_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_sign_3_argument arg;
	static ck_rv_c_Sign clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_Sign, xdr_c_sign_3_argument, &arg, xdr_ck_rv_c_Sign, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_signupdate_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_signupdate_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_SignUpdate, xdr_c_signupdate_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_SignFinal *
c_signfinal_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static ck_rv_c_SignFinal clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_SignFinal, xdr_rpc_ck_session_handle_t, &arg1, xdr_ck_rv_c_SignFinal, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_verifyinit_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_object_handle_t arg3;
	CLIENT *clnt;
{
	c_verifyinit_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_VerifyInit, xdr_c_verifyinit_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_verify_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	opaque_data arg3;
	CLIENT *clnt;
{
	c_verify_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_Verify, xdr_c_verify_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_verifyupdate_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_verifyupdate_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_VerifyUpdate, xdr_c_verifyupdate_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_verifyfinal_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_verifyfinal_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_VerifyFinal, xdr_c_verifyfinal_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_encryptinit_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_object_handle_t arg3;
	CLIENT *clnt;
{
	c_encryptinit_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_EncryptInit, xdr_c_encryptinit_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_Encrypt *
c_encrypt_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_encrypt_3_argument arg;
	static ck_rv_c_Encrypt clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_Encrypt, xdr_c_encrypt_3_argument, &arg, xdr_ck_rv_c_Encrypt, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_EncryptUpdate *
c_encryptupdate_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_encryptupdate_3_argument arg;
	static ck_rv_c_EncryptUpdate clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_EncryptUpdate, xdr_c_encryptupdate_3_argument, &arg, xdr_ck_rv_c_EncryptUpdate, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_EncryptFinal *
c_encryptfinal_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static ck_rv_c_EncryptFinal clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_EncryptFinal, xdr_rpc_ck_session_handle_t, &arg1, xdr_ck_rv_c_EncryptFinal, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_decryptinit_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_object_handle_t arg3;
	CLIENT *clnt;
{
	c_decryptinit_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_DecryptInit, xdr_c_decryptinit_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_Decrypt *
c_decrypt_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_decrypt_3_argument arg;
	static ck_rv_c_Decrypt clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_Decrypt, xdr_c_decrypt_3_argument, &arg, xdr_ck_rv_c_Decrypt, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_DecryptUpdate *
c_decryptupdate_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_decryptupdate_3_argument arg;
	static ck_rv_c_DecryptUpdate clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_DecryptUpdate, xdr_c_decryptupdate_3_argument, &arg, xdr_ck_rv_c_DecryptUpdate, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_DecryptFinal *
c_decryptfinal_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static ck_rv_c_DecryptFinal clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_DecryptFinal, xdr_rpc_ck_session_handle_t, &arg1, xdr_ck_rv_c_DecryptFinal, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_signrecoverinit_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_object_handle_t arg3;
	CLIENT *clnt;
{
	c_signrecoverinit_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_SignRecoverInit, xdr_c_signrecoverinit_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_SignRecover *
c_signrecover_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_signrecover_3_argument arg;
	static ck_rv_c_SignRecover clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_SignRecover, xdr_c_signrecover_3_argument, &arg, xdr_ck_rv_c_SignRecover, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_verifyrecoverinit_3(arg1, arg2, arg3, clnt)
	rpc_ck_session_handle_t arg1;
	rpc_ck_mechanism arg2;
	rpc_ck_object_handle_t arg3;
	CLIENT *clnt;
{
	c_verifyrecoverinit_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	if (clnt_call(clnt, c_VerifyRecoverInit, xdr_c_verifyrecoverinit_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_VerifyRecover *
c_verifyrecover_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_verifyrecover_3_argument arg;
	static ck_rv_c_VerifyRecover clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_VerifyRecover, xdr_c_verifyrecover_3_argument, &arg, xdr_ck_rv_c_VerifyRecover, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_DigestEncryptUpdate *
c_digestencryptupdate_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_digestencryptupdate_3_argument arg;
	static ck_rv_c_DigestEncryptUpdate clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_DigestEncryptUpdate, xdr_c_digestencryptupdate_3_argument, &arg, xdr_ck_rv_c_DigestEncryptUpdate, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_SignEncryptUpdate *
c_signencryptupdate_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_signencryptupdate_3_argument arg;
	static ck_rv_c_SignEncryptUpdate clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_SignEncryptUpdate, xdr_c_signencryptupdate_3_argument, &arg, xdr_ck_rv_c_SignEncryptUpdate, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_DecryptDigestUpdate *
c_decryptdigestupdate_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_decryptdigestupdate_3_argument arg;
	static ck_rv_c_DecryptDigestUpdate clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_DecryptDigestUpdate, xdr_c_decryptdigestupdate_3_argument, &arg, xdr_ck_rv_c_DecryptDigestUpdate, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_DecryptVerifyUpdate *
c_decryptverifyupdate_3(arg1, arg2, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	CLIENT *clnt;
{
	c_decryptverifyupdate_3_argument arg;
	static ck_rv_c_DecryptVerifyUpdate clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	if (clnt_call(clnt, c_DecryptVerifyUpdate, xdr_c_decryptverifyupdate_3_argument, &arg, xdr_ck_rv_c_DecryptVerifyUpdate, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

ck_rv_c_GetOperationState *
c_getoperationstate_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static ck_rv_c_GetOperationState clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_GetOperationState, xdr_rpc_ck_session_handle_t, &arg1, xdr_ck_rv_c_GetOperationState, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_setoperationstate_3(arg1, arg2, arg3, arg4, clnt)
	rpc_ck_session_handle_t arg1;
	opaque_data arg2;
	rpc_ck_object_handle_t arg3;
	rpc_ck_object_handle_t arg4;
	CLIENT *clnt;
{
	c_setoperationstate_3_argument arg;
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	arg.arg1 = arg1;
	arg.arg2 = arg2;
	arg.arg3 = arg3;
	arg.arg4 = arg4;
	if (clnt_call(clnt, c_SetOperationState, xdr_c_setoperationstate_3_argument, &arg, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_getfunctionstatus_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_GetFunctionStatus, xdr_rpc_ck_session_handle_t, &arg1, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_cancelfunction_3(arg1, clnt)
	rpc_ck_session_handle_t arg1;
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_CancelFunction, xdr_rpc_ck_session_handle_t, &arg1, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}

rpc_ck_rv_t *
c_loadmodule_3(arg1, clnt)
	opaque_data arg1;
	CLIENT *clnt;
{
	static rpc_ck_rv_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call(clnt, c_LoadModule, xdr_opaque_data, &arg1, xdr_rpc_ck_rv_t, &clnt_res, TIMEOUT) != RPC_SUCCESS)
		return (NULL);
	return (&clnt_res);
}
